[
  {
    "question_id": "abc365_b",
    "code_list": [
      "def main():\n    n = int(input().strip())\n    arr = list(map(int, input().split()))\n    \n    first_max = -1\n    second_max = -1\n    \n    for num in arr:\n        if num > first_max:\n            second_max = first_max\n            first_max = num\n        elif first_max > num > second_max:\n            second_max = num\n            \n    print(second_max)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc365_a",
    "code_list": [
      "def main():\n    Y = int(input().strip())\n    \n    if (Y % 4 == 0 and Y % 100 != 0) or (Y % 400 == 0):\n        print(366)\n    else:\n        print(365)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc366_b",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    \n    n = int(data[0])\n    strings = []\n    for i in range(1, n + 1):\n        strings.append(data[i].strip())\n    \n    max_len = max(len(s) for s in strings)\n    \n    result = []\n    for i in range(n, 0, -1):\n        s = strings[i - 1]\n        padding = max_len - len(s)\n        \n        # Create prefix: first i-1 characters of s\n        prefix = s[:i - 1]\n        \n        # Create suffix: last padding characters of s\n        suffix = s[-padding:]\n        \n        # Construct the row by alternating prefix and suffix\n        row = \"\"\n        for j in range(i - 1):\n            if j < len(prefix):\n                row += prefix[j]\n            else:\n                row += \"*\"\n        row += suffix\n        \n        result.append(row)\n    \n    print(\"\\n\".join(result))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc366_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    t = int(data[1])\n    a = int(data[2])\n    \n    if (t - a) % 2 == 0:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc367_a",
    "code_list": [
      "def main():\n    A, B, C = map(int, input().split())\n    \n    # Check if there's any overlap between sleep and wake-up times\n    if max(A, B) < min(C, 24 - A):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc367_b",
    "code_list": [
      "def main():\n    x = float(input().strip())\n    \n    # Convert to string and remove trailing zeros after decimal point\n    s = str(x).rstrip('0').rstrip('.')\n    \n    print(s)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc368_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    k = int(data[1])\n    \n    # Read the list of numbers\n    arr = []\n    for i in range(2, 2 + n):\n        arr.append(int(data[i]))\n    \n    # Take last k elements and move to front\n    result = arr[-k:] + arr[:-k]\n    \n    # Output the result\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc368_b",
    "code_list": [
      "def main():\n    n = int(input().strip())\n    arr = list(map(int, input().split()))\n    \n    count = 0\n    while len(arr) > 1:\n        # Sort in descending order\n        arr.sort(reverse=True)\n        \n        # Decrease first two elements\n        arr[0] -= 1\n        arr[1] -= 1\n        \n        # Check if we can perform another operation\n        if arr[0] <= 0 and arr[1] <= 0:\n            break\n            \n        count += 1\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc369_a",
    "code_list": [
      "def main():\n    A, B = map(int, input().split())\n    \n    # Find the common difference d\n    d = (B - A) // 2\n    \n    # Calculate the range of valid x values\n    min_x = max(A - d, 1)\n    max_x = min(B + d, 100)\n    \n    # Count how many integers in this range exist\n    count = max_x - min_x + 1\n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc369_b",
    "code_list": [
      "def main():\n    n = int(input().strip())\n    \n    min_left = float('inf')\n    max_right = -float('inf')\n    \n    for _ in range(n):\n        a, s = map(int, input().split())\n        \n        if s == 'L':\n            min_left = min(min_left, a)\n        else:  # s == 'R'\n            max_right = max(max_right, a)\n    \n    result = abs(min_left - max_right)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc370_a",
    "code_list": [
      "def main():\n    L, R = map(int, input().split())\n    \n    if L == 1 and R == 0:\n        print(\"Yes\")\n    elif L == 0 and R == 1:\n        print(\"No\")\n    else:\n        print(\"Invalid\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc370_b",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    \n    n = int(data[0])\n    matrix = []\n    index = 1\n    for i in range(n):\n        row = list(map(int, data[index:index + n]))\n        matrix.append(row)\n        index += n\n    \n    current = 1\n    for i in range(1, n + 1):\n        current = matrix[current - 1][i - 1]\n    \n    print(current)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc371_b",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    families = [[] for _ in range(n + 1)]\n    \n    index = 2\n    for i in range(m):\n        a = int(data[index])  # family number\n        b = data[index + 1]  # gender ('M' or 'F')\n        \n        if b == 'M':\n            families[a].append(i)\n        index += 2\n    \n    results = []\n    for i in range(m):\n        family_index = families[i + 1]\n        if len(family_index) > 0:\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc371_a",
    "code_list": [
      "def main():\n    s = input().split()\n    \n    # Parse the inequalities\n    ab = s[0]\n    ac = s[1]\n    bc = s[2]\n    \n    # Determine the order: A, B, C\n    if ab == '<':\n        a_b = True\n    else:\n        a_b = False\n        \n    if ac == '<':\n        a_c = True\n    else:\n        a_c = False\n        \n    if bc == '<':\n        b_c = True\n    else:\n        b_c = False\n        \n    # Find the middle brother\n    if a_b and not a_c and not b_c:\n        print('A')\n    elif not a_b and a_c and not b_c:\n        print('B')\n    elif not a_b and not a_c and b_c:\n        print('C')\n    else:\n        raise ValueError(\"Invalid input\")\n\nif __name__ == '__main__':\n    main()"
    ]
  },
  {
    "question_id": "abc372_a",
    "code_list": [
      "def main():\n    s = input().strip()\n    result = []\n    for char in s:\n        if char != '.':\n            result.append(char)\n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc373_a",
    "code_list": [
      "def main():\n    count = 0\n    for i in range(1, 13):\n        valid = True\n        for s in range(i):\n            if len(input().strip()) != i:\n                valid = False\n                break\n        if valid:\n            count += 1\n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc373_b",
    "code_list": [
      "def main():\n    s = input().strip()\n    \n    # Create dictionary mapping characters to their positions\n    char_to_pos = {}\n    for i, ch in enumerate(s):\n        char_to_pos[ch] = i + 1\n    \n    # Calculate total distance using sum of absolute differences\n    total_distance = 0\n    for ch in s:\n        pos = char_to_pos[ch]\n        total_distance += abs(pos - 1)\n    \n    print(total_distance)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc374_b",
    "code_list": [
      "def main():\n    s = input().strip()\n    t = input().strip()\n    \n    min_len = min(len(s), len(t))\n    \n    for i in range(min_len):\n        if s[i] != t[i]:\n            print(i + 1)\n            return\n    \n    # If all characters match up to min_len, compare lengths\n    if len(s) == len(t):\n        print(0)\n    else:\n        print(min_len + 1)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc374_a",
    "code_list": [
      "def main():\n    s = input().strip()\n    if s.endswith(\"san\"):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc375_b",
    "code_list": [
      "import sys\nfrom math import sqrt\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    \n    points = []\n    index = 1\n    for i in range(n):\n        x = int(data[index]); y = int(data[index+1])\n        index += 2\n        points.append((x, y))\n    \n    # Calculate distances between consecutive points\n    distances = []\n    for i in range(n):\n        p1 = points[i]\n        p2 = points[(i + 1) % n]  # Wrap around to first point\n        dx = p2[0] - p1[0]\n        dy = p2[1] - p1[1]\n        dist = sqrt(dx * dx + dy * dy)\n        distances.append(dist)\n    \n    # Calculate distance from last point back to origin\n    last_point = points[-1]\n    dx = last_point[0]\n    dy = last_point[1]\n    dist_back = sqrt(dx * dx + dy * dy)\n    distances.append(dist_back)\n    \n    total_cost = sum(distances)\n    print(f\"{total_cost:.15f}\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc375_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    n = int(data[0])\n    s = data[1].strip()\n    \n    count = 0\n    for i in range(n - 2):\n        if s[i] == '#' and s[i+1] == '#' and s[i+2] == '.':\n            count += 1\n            \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc376_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    c = int(data[1])\n    times = list(map(int, data[2:2+n]))\n    \n    count = 0\n    for t in times:\n        if t >= c:\n            count += 1\n            \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc377_b",
    "code_list": [
      "def main():\n    grid = []\n    for _ in range(8):\n        grid.append(input().strip())\n    \n    count = 0\n    \n    # Check rows\n    for i in range(8):\n        for j in range(8):\n            if grid[i][j] == '.':\n                valid = True\n                # Check if there's any piece in same row\n                for k in range(8):\n                    if grid[i][k] == '#':\n                        valid = False\n                        break\n                if not valid:\n                    continue\n                \n                # Check if there's any piece in same column\n                for k in range(8):\n                    if grid[k][j] == '#':\n                        valid = False\n                        break\n                if not valid:\n                    continue\n                \n                count += 1\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc377_a",
    "code_list": [
      "def main():\n    s = input().strip()\n    \n    # Check if all characters are distinct\n    if len(set(s)) != 3:\n        print(\"No\")\n        return\n    \n    # Check if we have at least one 'A', one 'B', and one 'C'\n    if 'A' not in s or 'B' not in s or 'C' not in s:\n        print(\"No\")\n        return\n    \n    # Check if we have exactly one character that appears twice\n    count_A = s.count('A')\n    count_B = s.count('B')\n    count_C = s.count('C')\n    \n    if count_A == 2 and count_B == 1 and count_C == 0:\n        print(\"Yes\")\n        return\n    elif count_A == 1 and count_B == 2 and count_C == 0:\n        print(\"Yes\")\n        return\n    elif count_A == 0 and count_B == 1 and count_C == 2:\n        print(\"Yes\")\n        return\n    \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc378_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    \n    # Precompute modular inverses up to 10**9\n    mod = 10**9 + 7\n    inv = [1] * (mod + 1)\n    for i in range(2, mod + 1):\n        inv[i] = (mod - mod // i) * inv[mod % i] % mod\n    \n    # Precompute powers of 2 modulo mod\n    pow2 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow2[i] = (pow2[i - 1] * 2) % mod\n    \n    # Precompute powers of 3 modulo mod\n    pow3 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow3[i] = (pow3[i - 1] * 3) % mod\n    \n    # Precompute powers of 5 modulo mod\n    pow5 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow5[i] = (pow5[i - 1] * 5) % mod\n    \n    # Precompute powers of 7 modulo mod\n    pow7 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow7[i] = (pow7[i - 1] * 7) % mod\n    \n    # Precompute powers of 8 modulo mod\n    pow8 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow8[i] = (pow8[i - 1] * 8) % mod\n    \n    # Precompute powers of 9 modulo mod\n    pow9 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow9[i] = (pow9[i - 1] * 9) % mod\n    \n    # Precompute powers of 10 modulo mod\n    pow10 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow10[i] = (pow10[i - 1] * 10) % mod\n    \n    # Precompute powers of 11 modulo mod\n    pow11 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow11[i] = (pow11[i - 1] * 11) % mod\n    \n    # Precompute powers of 12 modulo mod\n    pow12 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow12[i] = (pow12[i - 1] * 12) % mod\n    \n    # Precompute powers of 13 modulo mod\n    pow13 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow13[i] = (pow13[i - 1] * 13) % mod\n    \n    # Precompute powers of 14 modulo mod\n    pow14 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow14[i] = (pow14[i - 1] * 14) % mod\n    \n    # Precompute powers of 15 modulo mod\n    pow15 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow15[i] = (pow15[i - 1] * 15) % mod\n    \n    # Precompute powers of 16 modulo mod\n    pow16 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow16[i] = (pow16[i - 1] * 16) % mod\n    \n    # Precompute powers of 17 modulo mod\n    pow17 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow17[i] = (pow17[i - 1] * 17) % mod\n    \n    # Precompute powers of 18 modulo mod\n    pow18 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow18[i] = (pow18[i - 1] * 18) % mod\n    \n    # Precompute powers of 19 modulo mod\n    pow19 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow19[i] = (pow19[i - 1] * 19) % mod\n    \n    # Precompute powers of 20 modulo mod\n    pow20 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow20[i] = (pow20[i - 1] * 20) % mod\n    \n    # Precompute powers of 21 modulo mod\n    pow21 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow21[i] = (pow21[i - 1] * 21) % mod\n    \n    # Precompute powers of 22 modulo mod\n    pow22 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow22[i] = (pow22[i - 1] * 22) % mod\n    \n    # Precompute powers of 23 modulo mod\n    pow23 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow23[i] = (pow23[i - 1] * 23) % mod\n    \n    # Precompute powers of 24 modulo mod\n    pow24 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow24[i] = (pow24[i - 1] * 24) % mod\n    \n    # Precompute powers of 25 modulo mod\n    pow25 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow25[i] = (pow25[i - 1] * 25) % mod\n    \n    # Precompute powers of 26 modulo mod\n    pow26 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow26[i] = (pow26[i - 1] * 26) % mod\n    \n    # Precompute powers of 27 modulo mod\n    pow27 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow27[i] = (pow27[i - 1] * 27) % mod\n    \n    # Precompute powers of 28 modulo mod\n    pow28 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow28[i] = (pow28[i - 1] * 28) % mod\n    \n    # Precompute powers of 29 modulo mod\n    pow29 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow29[i] = (pow29[i - 1] * 29) % mod\n    \n    # Precompute powers of 30 modulo mod\n    pow30 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow30[i] = (pow30[i - 1] * 30) % mod\n    \n    # Precompute powers of 31 modulo mod\n    pow31 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow31[i] = (pow31[i - 1] * 31) % mod\n    \n    # Precompute powers of 32 modulo mod\n    pow32 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow32[i] = (pow32[i - 1] * 32) % mod\n    \n    # Precompute powers of 33 modulo mod\n    pow33 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow33[i] = (pow33[i - 1] * 33) % mod\n    \n    # Precompute powers of 34 modulo mod\n    pow34 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow34[i] = (pow34[i - 1] * 34) % mod\n    \n    # Precompute powers of 35 modulo mod\n    pow35 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow35[i] = (pow35[i - 1] * 35) % mod\n    \n    # Precompute powers of 36 modulo mod\n    pow36 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow36[i] = (pow36[i - 1] * 36) % mod\n    \n    # Precompute powers of 37 modulo mod\n    pow37 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow37[i] = (pow37[i - 1] * 37) % mod\n    \n    # Precompute powers of 38 modulo mod\n    pow38 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow38[i] = (pow38[i - 1] * 38) % mod\n    \n    # Precompute powers of 39 modulo mod\n    pow39 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow39[i] = (pow39[i - 1] * 39) % mod\n    \n    # Precompute powers of 40 modulo mod\n    pow40 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow40[i] = (pow40[i - 1] * 40) % mod\n    \n    # Precompute powers of 41 modulo mod\n    pow41 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow41[i] = (pow41[i - 1] * 41) % mod\n    \n    # Precompute powers of 42 modulo mod\n    pow42 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow42[i] = (pow42[i - 1] * 42) % mod\n    \n    # Precompute powers of 43 modulo mod\n    pow43 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow43[i] = (pow43[i - 1] * 43) % mod\n    \n    # Precompute powers of 44 modulo mod\n    pow44 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow44[i] = (pow44[i - 1] * 44) % mod\n    \n    # Precompute powers of 45 modulo mod\n    pow45 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow45[i] = (pow45[i - 1] * 45) % mod\n    \n    # Precompute powers of 46 modulo mod\n    pow46 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow46[i] = (pow46[i - 1] * 46) % mod\n    \n    # Precompute powers of 47 modulo mod\n    pow47 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow47[i] = (pow47[i - 1] * 47) % mod\n    \n    # Precompute powers of 48 modulo mod\n    pow48 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow48[i] = (pow48[i - 1] * 48) % mod\n    \n    # Precompute powers of 49 modulo mod\n    pow49 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow49[i] = (pow49[i - 1] * 49) % mod\n    \n    # Precompute powers of 50 modulo mod\n    pow50 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow50[i] = (pow50[i - 1] * 50) % mod\n    \n    # Precompute powers of 51 modulo mod\n    pow51 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow51[i] = (pow51[i - 1] * 51) % mod\n    \n    # Precompute powers of 52 modulo mod\n    pow52 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow52[i] = (pow52[i - 1] * 52) % mod\n    \n    # Precompute powers of 53 modulo mod\n    pow53 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow53[i] = (pow53[i - 1] * 53) % mod\n    \n    # Precompute powers of 54 modulo mod\n    pow54 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow54[i] = (pow54[i - 1] * 54) % mod\n    \n    # Precompute powers of 55 modulo mod\n    pow55 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow55[i] = (pow55[i - 1] * 55) % mod\n    \n    # Precompute powers of 56 modulo mod\n    pow56 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow56[i] = (pow56[i - 1] * 56) % mod\n    \n    # Precompute powers of 57 modulo mod\n    pow57 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow57[i] = (pow57[i - 1] * 57) % mod\n    \n    # Precompute powers of 58 modulo mod\n    pow58 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow58[i] = (pow58[i - 1] * 58) % mod\n    \n    # Precompute powers of 59 modulo mod\n    pow59 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow59[i] = (pow59[i - 1] * 59) % mod\n    \n    # Precompute powers of 60 modulo mod\n    pow60 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow60[i] = (pow60[i - 1] * 60) % mod\n    \n    # Precompute powers of 61 modulo mod\n    pow61 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow61[i] = (pow61[i - 1] * 61) % mod\n    \n    # Precompute powers of 62 modulo mod\n    pow62 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow62[i] = (pow62[i - 1] * 62) % mod\n    \n    # Precompute powers of 63 modulo mod\n    pow63 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow63[i] = (pow63[i - 1] * 63) % mod\n    \n    # Precompute powers of 64 modulo mod\n    pow64 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow64[i] = (pow64[i - 1] * 64) % mod\n    \n    # Precompute powers of 65 modulo mod\n    pow65 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow65[i] = (pow65[i - 1] * 65) % mod\n    \n    # Precompute powers of 66 modulo mod\n    pow66 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow66[i] = (pow66[i - 1] * 66) % mod\n    \n    # Precompute powers of 67 modulo mod\n    pow67 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow67[i] = (pow67[i - 1] * 67) % mod\n    \n    # Precompute powers of 68 modulo mod\n    pow68 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow68[i] = (pow68[i - 1] * 68) % mod\n    \n    # Precompute powers of 69 modulo mod\n    pow69 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow69[i] = (pow69[i - 1] * 69) % mod\n    \n    # Precompute powers of 70 modulo mod\n    pow70 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow70[i] = (pow70[i - 1] * 70) % mod\n    \n    # Precompute powers of 71 modulo mod\n    pow71 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow71[i] = (pow71[i - 1] * 71) % mod\n    \n    # Precompute powers of 72 modulo mod\n    pow72 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow72[i] = (pow72[i - 1] * 72) % mod\n    \n    # Precompute powers of 73 modulo mod\n    pow73 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow73[i] = (pow73[i - 1] * 73) % mod\n    \n    # Precompute powers of 74 modulo mod\n    pow74 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow74[i] = (pow74[i - 1] * 74) % mod\n    \n    # Precompute powers of 75 modulo mod\n    pow75 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow75[i] = (pow75[i - 1] * 75) % mod\n    \n    # Precompute powers of 76 modulo mod\n    pow76 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow76[i] = (pow76[i - 1] * 76) % mod\n    \n    # Precompute powers of 77 modulo mod\n    pow77 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow77[i] = (pow77[i - 1] * 77) % mod\n    \n    # Precompute powers of 78 modulo mod\n    pow78 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow78[i] = (pow78[i - 1] * 78) % mod\n    \n    # Precompute powers of 79 modulo mod\n    pow79 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow79[i] = (pow79[i - 1] * 79) % mod\n    \n    # Precompute powers of 80 modulo mod\n    pow80 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow80[i] = (pow80[i - 1] * 80) % mod\n    \n    # Precompute powers of 81 modulo mod\n    pow81 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow81[i] = (pow81[i - 1] * 81) % mod\n    \n    # Precompute powers of 82 modulo mod\n    pow82 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow82[i] = (pow82[i - 1] * 82) % mod\n    \n    # Precompute powers of 83 modulo mod\n    pow83 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow83[i] = (pow83[i - 1] * 83) % mod\n    \n    # Precompute powers of 84 modulo mod\n    pow84 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow84[i] = (pow84[i - 1] * 84) % mod\n    \n    # Precompute powers of 85 modulo mod\n    pow85 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow85[i] = (pow85[i - 1] * 85) % mod\n    \n    # Precompute powers of 86 modulo mod\n    pow86 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow86[i] = (pow86[i - 1] * 86) % mod\n    \n    # Precompute powers of 87 modulo mod\n    pow87 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow87[i] = (pow87[i - 1] * 87) % mod\n    \n    # Precompute powers of 88 modulo mod\n    pow88 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow88[i] = (pow88[i - 1] * 88) % mod\n    \n    # Precompute powers of 89 modulo mod\n    pow89 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow89[i] = (pow89[i - 1] * 89) % mod\n    \n    # Precompute powers of 90 modulo mod\n    pow90 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow90[i] = (pow90[i - 1] * 90) % mod\n    \n    # Precompute powers of 91 modulo mod\n    pow91 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow91[i] = (pow91[i - 1] * 91) % mod\n    \n    # Precompute powers of 92 modulo mod\n    pow92 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow92[i] = (pow92[i - 1] * 92) % mod\n    \n    # Precompute powers of 93 modulo mod\n    pow93 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow93[i] = (pow93[i - 1] * 93) % mod\n    \n    # Precompute powers of 94 modulo mod\n    pow94 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow94[i] = (pow94[i - 1] * 94) % mod\n    \n    # Precompute powers of 95 modulo mod\n    pow95 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow95[i] = (pow95[i - 1] * 95) % mod\n    \n    # Precompute powers of 96 modulo mod\n    pow96 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow96[i] = (pow96[i - 1] * 96) % mod\n    \n    # Precompute powers of 97 modulo mod\n    pow97 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow97[i] = (pow97[i - 1] * 97) % mod\n    \n    # Precompute powers of 98 modulo mod\n    pow98 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow98[i] = (pow98[i - 1] * 98) % mod\n    \n    # Precompute powers of 99 modulo mod\n    pow99 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow99[i] = (pow99[i - 1] * 99) % mod\n    \n    # Precompute powers of 100 modulo mod\n    pow100 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow100[i] = (pow100[i - 1] * 100) % mod\n    \n    # Precompute powers of 101 modulo mod\n    pow101 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow101[i] = (pow101[i - 1] * 101) % mod\n    \n    # Precompute powers of 102 modulo mod\n    pow102 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow102[i] = (pow102[i - 1] * 102) % mod\n    \n    # Precompute powers of 103 modulo mod\n    pow103 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow103[i] = (pow103[i - 1] * 103) % mod\n    \n    # Precompute powers of 104 modulo mod\n    pow104 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow104[i] = (pow104[i - 1] * 104) % mod\n    \n    # Precompute powers of 105 modulo mod\n    pow105 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow105[i] = (pow105[i - 1] * 105) % mod\n    \n    # Precompute powers of 106 modulo mod\n    pow106 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow106[i] = (pow106[i - 1] * 106) % mod\n    \n    # Precompute powers of 107 modulo mod\n    pow107 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow107[i] = (pow107[i - 1] * 107) % mod\n    \n    # Precompute powers of 108 modulo mod\n    pow108 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow108[i] = (pow108[i - 1] * 108) % mod\n    \n    # Precompute powers of 109 modulo mod\n    pow109 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow109[i] = (pow109[i - 1] * 109) % mod\n    \n    # Precompute powers of 110 modulo mod\n    pow110 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow110[i] = (pow110[i - 1] * 110) % mod\n    \n    # Precompute powers of 111 modulo mod\n    pow111 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow111[i] = (pow111[i - 1] * 111) % mod\n    \n    # Precompute powers of 112 modulo mod\n    pow112 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow112[i] = (pow112[i - 1] * 112) % mod\n    \n    # Precompute powers of 113 modulo mod\n    pow113 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow113[i] = (pow113[i - 1] * 113) % mod\n    \n    # Precompute powers of 114 modulo mod\n    pow114 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow114[i] = (pow114[i - 1] * 114) % mod\n    \n    # Precompute powers of 115 modulo mod\n    pow115 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow115[i] = (pow115[i - 1] * 115) % mod\n    \n    # Precompute powers of 116 modulo mod\n    pow116 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow116[i] = (pow116[i - 1] * 116) % mod\n    \n    # Precompute powers of 117 modulo mod\n    pow117 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow117[i] = (pow117[i - 1] * 117) % mod\n    \n    # Precompute powers of 118 modulo mod\n    pow118 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow118[i] = (pow118[i - 1] * 118) % mod\n    \n    # Precompute powers of 119 modulo mod\n    pow119 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow119[i] = (pow119[i - 1] * 119) % mod\n    \n    # Precompute powers of 120 modulo mod\n    pow120 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow120[i] = (pow120[i - 1] * 120) % mod\n    \n    # Precompute powers of 121 modulo mod\n    pow121 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow121[i] = (pow121[i - 1] * 121) % mod\n    \n    # Precompute powers of 122 modulo mod\n    pow122 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow122[i] = (pow122[i - 1] * 122) % mod\n    \n    # Precompute powers of 123 modulo mod\n    pow123 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow123[i] = (pow123[i - 1] * 123) % mod\n    \n    # Precompute powers of 124 modulo mod\n    pow124 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow124[i] = (pow124[i - 1] * 124) % mod\n    \n    # Precompute powers of 125 modulo mod\n    pow125 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow125[i] = (pow125[i - 1] * 125) % mod\n    \n    # Precompute powers of 126 modulo mod\n    pow126 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow126[i] = (pow126[i - 1] * 126) % mod\n    \n    # Precompute powers of 127 modulo mod\n    pow127 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow127[i] = (pow127[i - 1] * 127) % mod\n    \n    # Precompute powers of 128 modulo mod\n    pow128 = [1] * (mod + 1)\n    for i in range(1, mod + 1):\n        pow128"
    ]
  },
  {
    "question_id": "abc378_a",
    "code_list": [
      "def main():\n    colors = list(map(int, input().split()))\n    \n    # Count occurrences of each color\n    freq = {}\n    for color in colors:\n        freq[color] = freq.get(color, 0) + 1\n    \n    # Find the minimum frequency (number of balls with that color)\n    min_freq = min(freq.values())\n    \n    print(min_freq)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc379_b",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    n, k = map(int, data[0].split())\n    s = data[1].strip()\n    \n    count = 0\n    current_count = 0\n    \n    for char in s:\n        if char == 'O':\n            current_count += 1\n            if current_count >= k:\n                count += 1\n                current_count -= k\n        else:  # char == 'X'\n            current_count = 0\n            \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc379_a",
    "code_list": [
      "def main():\n    n = int(input().strip())\n    \n    # Extract digits\n    hundreds = n // 100\n    tens = (n // 10) % 10\n    ones = n % 10\n    \n    # Form numbers with digits in new order\n    num1 = tens * 100 + ones * 10 + hundreds\n    num2 = hundreds * 100 + ones * 10 + tens\n    \n    print(f\"{num1} {num2}\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc380_a",
    "code_list": [
      "def main():\n    n = int(input().strip())\n    \n    # Convert to string to easily access individual digits\n    s = str(n)\n    \n    # Check frequency of each digit\n    freq = {}\n    for char in s:\n        if char in freq:\n            freq[char] += 1\n        else:\n            freq[char] = 1\n    \n    # Check conditions\n    if freq.get('1', 0) != 1 or freq.get('2', 0) != 2 or freq.get('3', 0) != 3:\n        print(\"No\")\n    else:\n        print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc380_b",
    "code_list": [
      "def main():\n    s = input().strip()\n    \n    # Find all occurrences of '|' and '-'\n    positions = []\n    for i, char in enumerate(s):\n        if char == '|':\n            positions.append(i)\n    \n    # Extract numbers from positions\n    numbers = []\n    for pos in positions[::2]:\n        # The number starts after the '-' character\n        start = pos + 1\n        # The number ends just before the next '|' or the end of the string\n        end = None\n        if pos + 2 < len(s):\n            end = pos + 2\n        else:\n            end = len(s)\n        \n        # Extract the substring and convert to integer\n        num_str = s[start:end]\n        numbers.append(int(num_str))\n    \n    print(' '.join(map(str, numbers)))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc381_a",
    "code_list": [
      "def main():\n    n = int(input().strip())\n    s = input().strip()\n    \n    if n % 2 == 0:\n        print(\"No\")\n        return\n    \n    # Check first condition: |T| must be odd\n    if n % 2 != 1:\n        print(\"No\")\n        return\n        \n    # Check second condition: 1st to (n//2) characters should be '1'\n    count_ones = 0\n    for i in range(n):\n        if s[i] == '1':\n            count_ones += 1\n            \n    if count_ones != n // 2:\n        print(\"No\")\n        return\n        \n    # Check third condition: (n//2)+1-th character should be '/'\n    if s[n // 2] != '/':\n        print(\"No\")\n        return\n        \n    # Check fourth condition: (n//2)+2 to end should be '2'\n    count_twos = 0\n    for i in range(n // 2 + 1, n):\n        if s[i] == '2':\n            count_twos += 1\n            \n    if count_twos != n // 2:\n        print(\"No\")\n        return\n        \n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc381_b",
    "code_list": [
      "def main():\n    s = input().strip()\n    \n    # Check if length is even\n    if len(s) % 2 != 0:\n        print(\"No\")\n        return\n    \n    n = len(s)\n    half = n // 2\n    \n    # Count frequency of each character\n    freq = {}\n    for char in s:\n        freq[char] = freq.get(char, 0) + 1\n    \n    # Check if all characters appear exactly twice\n    for count in freq.values():\n        if count != 2:\n            print(\"No\")\n            return\n    \n    # Check if all pairs match\n    for i in range(half):\n        if s[i] != s[i + half]:\n            print(\"No\")\n            return\n    \n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc382_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    n, d = map(int, data[0].split())\n    s = data[1].strip()\n    \n    # Count initial empty boxes\n    empty_count = s.count('.')\n    \n    for _ in range(d):\n        # Find all positions where we can place a cookie\n        places = []\n        for i in range(n):\n            if s[i] == '.':\n                places.append(i)\n        \n        # If no valid placement found, break\n        if not places:\n            break\n        \n        # Place a cookie at the first available position\n        pos = places[0]\n        s = s[:pos] + '@' + s[pos+1:]\n        empty_count -= 1\n    \n    print(empty_count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc382_b",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    n, d = map(int, data[0].split())\n    s = data[1].strip()\n    \n    result = []\n    for i in range(n):\n        if s[i] == '@':\n            result.append('@')\n        else:\n            # Find last occurrence of @ to the right of position i\n            pos = i + 1\n            while pos < n and s[pos] != '@':\n                pos += 1\n            if pos < n:\n                result.append('.')\n            else:\n                result.append(' ')\n    \n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc383_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    \n    n = int(data[0])\n    times = []\n    volumes = []\n    \n    index = 1\n    for i in range(n):\n        t = int(data[index]); v = int(data[index + 1])\n        times.append(t)\n        volumes.append(v)\n        index += 2\n    \n    total_water = 0\n    for i in range(n - 1):\n        total_water += volumes[i]\n    \n    print(total_water)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc384_b",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    \n    n = int(data[0])\n    r = int(data[1])\n    \n    results = []\n    index = 2\n    \n    for i in range(n):\n        d = int(data[index]); a = int(data[index + 1])\n        index += 2\n        \n        if d == 1:  # Div. 1\n            if r >= 1600 and r <= 2799:\n                r += a\n        else:  # Div. 2\n            if r >= 1200 and r <= 2399:\n                r += a\n                \n        results.append(str(r))\n        \n    print(' '.join(results))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc384_a",
    "code_list": [
      "def main():\n    data = input().split()\n    n = int(data[0])\n    c1 = data[1]\n    c2 = data[2]\n    s = input().strip()\n    \n    result = []\n    for char in s:\n        if char != c1:\n            result.append(c2)\n        else:\n            result.append(char)\n    \n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc385_a",
    "code_list": [
      "def main():\n    A, B, C = map(int, input().split())\n    \n    total_sum = A + B + C\n    \n    if total_sum % 2 != 0:\n        print(\"No\")\n        return\n        \n    target = total_sum // 2\n    \n    # Check if we can form a subset of target using A, B, C\n    def can_form_subset(target):\n        if target == 0:\n            return True\n            \n        # Try all combinations of A, B, C\n        for a in range(A + 1):\n            for b in range(B + 1):\n                c_remaining = target - a - b\n                if c_remaining >= 0 and c_remaining <= C:\n                    if can_form_subset(c_remaining):\n                        return True\n        return False\n    \n    if can_form_subset(target):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc385_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    if not data:\n        return\n    \n    lines = []\n    for line in data:\n        if line.strip():\n            lines.append(line.strip())\n    \n    H, W, X, Y = map(int, lines[0].split())\n    grid = []\n    for i in range(1, 1 + H):\n        grid.append(lines[i].strip())\n    \n    T = lines[-1]\n    \n    current_x, current_y = X - 1, Y - 1\n    visited = set()\n    visited.add((current_x, current_y))\n    \n    for char in T:\n        new_x, new_y = current_x, current_y\n        \n        if char == 'U':\n            new_y -= 1\n        elif char == 'D':\n            new_y += 1\n        elif char == 'L':\n            new_x -= 1\n        elif char == 'R':\n            new_x += 1\n            \n        if 0 <= new_x < H and 0 <= new_y < W:\n            if grid[new_x][new_y] == '.':\n                current_x, current_y = new_x, new_y\n                visited.add((current_x, current_y))\n                \n    result = [str(current_x + 1), str(current_y + 1)]\n    count = len(visited)\n    result.append(str(count))\n    \n    print(' '.join(result))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc386_a",
    "code_list": [
      "def main():\n    A, B, C, D = map(int, input().split())\n    \n    # Check if all four numbers are equal\n    if A == B == C == D:\n        print(\"No\")\n        return\n    \n    # Count frequency of each number\n    freq = {}\n    for num in [A, B, C, D]:\n        freq[num] = freq.get(num, 0) + 1\n    \n    # Find the most frequent number (count >= 3)\n    max_count = 0\n    for count in freq.values():\n        if count >= 3:\n            max_count = count\n    \n    # If we have at least one number with count >= 3, it's possible\n    if max_count >= 3:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc386_b",
    "code_list": [
      "def main():\n    s = input().strip()\n    \n    # Precompute all prefixes that can be formed by appending digits to the end\n    prefix_set = set()\n    current = \"\"\n    \n    for char in s:\n        current += char\n        prefix_set.add(current)\n    \n    # Find the shortest prefix that contains all characters in s\n    min_length = float('inf')\n    best_prefix = \"\"\n    \n    for prefix in prefix_set:\n        if len(prefix) < min_length:\n            min_length = len(prefix)\n            best_prefix = prefix\n    \n    print(min_length)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  }
]