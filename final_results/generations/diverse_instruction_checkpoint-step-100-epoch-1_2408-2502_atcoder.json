[
  {
    "question_id": "abc365_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    first_max = float('-inf')\n    second_max = float('-inf')\n    \n    for num in arr:\n        if num > first_max:\n            second_max = first_max\n            first_max = num\n        elif first_max > num > second_max:\n            second_max = num\n            \n    print(second_max)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc365_a",
    "code_list": [
      "def main():\n    y = int(input().strip())\n    \n    if (y % 4 == 0 and y % 100 != 0) or (y % 400 == 0):\n        print(366)\n    else:\n        print(365)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc366_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    n = int(data[0])\n    strings = data[1:1+n]\n    \n    max_len = 0\n    for s in strings:\n        if len(s) > max_len:\n            max_len = len(s)\n    \n    result = []\n    for i in range(n):\n        current_str = strings[i]\n        current_len = len(current_str)\n        \n        # Calculate how many characters we need to fill\n        total_chars_needed = max_len - current_len\n        \n        # Generate all possible combinations of characters from the remaining positions\n        # We'll use a bitmask approach to generate all combinations\n        # The mask will represent which characters are used\n        # We'll iterate over all masks and check if they form valid strings\n        \n        # First, generate all possible combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        remaining_chars = max_len - current_len\n        if remaining_chars == 0:\n            # If no characters remain, we can't place * anywhere\n            continue\n            \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll start with all zeros (no characters used) and go up to all ones (all characters used)\n        # But since we only need combinations of the remaining characters, we'll stop at 2^remaining_chars\n        \n        # Generate all combinations using bitmask\n        # We'll use bitmasks where each bit represents whether a character is used\n        # We'll"
    ]
  },
  {
    "question_id": "abc366_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    t = int(data[1])\n    a = int(data[2])\n    \n    if (t - a) % 2 == 0:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc367_a",
    "code_list": [
      "def main():\n    A, B, C = map(int, input().split())\n    \n    # Check if there's a common hour between B and C\n    if B <= C:\n        if B >= A:\n            print(\"Yes\")\n        else:\n            print(\"No\")\n    else:  # B > C\n        if C >= A:\n            print(\"Yes\")\n        else:\n            print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc367_b",
    "code_list": [
      "x = float(input().strip())\nif x == int(x):\n    print(int(x))\nelse:\n    print(f\"{x:.3f}\")"
    ]
  },
  {
    "question_id": "abc368_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    \n    stack = list(map(int, data[2:2+n]))\n    \n    # Take last k elements\n    taken = stack[-k:]\n    \n    # Remove these elements from original stack\n    stack = stack[:-k]\n    \n    # Add taken elements at the beginning\n    stack.extend(taken)\n    \n    print(' '.join(map(str, stack)))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc368_b",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    arr = list(map(int, data[1:1+n]))\n    \n    count = 0\n    while len(arr) > 1:\n        # Sort in descending order\n        arr.sort(reverse=True)\n        \n        # Decrease first two elements\n        arr[0] -= 1\n        arr[1] -= 1\n        \n        # Count how many elements became zero\n        zeros_count = sum(1 for x in arr if x == 0)\n        count += zeros_count\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc369_a",
    "code_list": [
      "def main():\n    a, b = map(int, input().split())\n    \n    # Calculate differences\n    diff_ab = abs(a - b)\n    diff_aa = abs(a - a)\n    diff_bb = abs(b - b)\n    \n    # Count valid x values\n    count = 0\n    \n    # Check x = a + diff_ab\n    if (a + diff_ab) % 2 == 0:\n        count += 1\n        \n    # Check x = a + diff_aa\n    if (a + diff_aa) % 2 == 0:\n        count += 1\n        \n    # Check x = a + diff_bb\n    if (a + diff_bb) % 2 == 0:\n        count += 1\n        \n    # Check x = b + diff_ab\n    if (b + diff_ab) % 2 == 0:\n        count += 1\n        \n    # Check x = b + diff_aa\n    if (b + diff_aa) % 2 == 0:\n        count += 1\n        \n    # Check x = b + diff_bb\n    if (b + diff_bb) % 2 == 0:\n        count += 1\n        \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc369_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    presses = []\n    \n    index = 1\n    for i in range(n):\n        a = int(data[index]); s = data[index + 1]\n        index += 2\n        presses.append((a, s))\n    \n    # Initialize DP arrays\n    dp_left = [float('inf')] * 101\n    dp_right = [float('inf')] * 101\n    \n    # Initial state: no hands on any key\n    dp_left[0] = 0\n    dp_right[0] = 0\n    \n    for a, s in presses:\n        new_dp_left = [float('inf')] * 101\n        new_dp_right = [float('inf')] * 101\n        \n        # Update left hand positions\n        for pos in range(101):\n            if dp_left[pos] != float('inf'):\n                new_pos = pos - 1\n                if new_pos >= 0:\n                    new_dp_left[new_pos] = min(new_dp_left[new_pos], dp_left[pos] + abs(pos - a))\n        \n        # Update right hand positions\n        for pos in range(101):\n            if dp_right[pos] != float('inf'):\n                new_pos = pos + 1\n                if new_pos <= 100:\n                    new_dp_right[new_pos] = min(new_dp_right[new_pos], dp_right[pos] + abs(pos - a))\n        \n        # Update overall states\n        for pos in range(101):\n            if new_dp_left[pos] != float('inf') and new_dp_right[pos] != float('inf'):\n                dp_left[pos] = min(dp_left[pos], new_dp_left[pos])\n                dp_right[pos] = min(dp_right[pos], new_dp_right[pos])\n    \n    result = min(dp_left[0], dp_right[0])\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc370_a",
    "code_list": [
      "def main():\n    L, R = map(int, input().split())\n    \n    if L == 1 and R == 0:\n        print(\"Yes\")\n    elif L == 0 and R == 1:\n        print(\"No\")\n    else:\n        print(\"Invalid\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc370_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    matrix = []\n    index = 1\n    for i in range(n):\n        row = list(map(int, data[index:index+n]))\n        index += n\n        matrix.append(row)\n    \n    current_element = 1\n    \n    for i in range(1, n + 1):\n        current_element = matrix[current_element - 1][i - 1]\n    \n    print(current_element)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc371_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    m = int(data[1])\n    \n    # Initialize arrays for families and genders\n    families = [[] for _ in range(n + 1)]\n    genders = [None] * (n + 1)\n    \n    index = 2\n    for i in range(m):\n        family_id = int(data[index])\n        gender = data[index + 1]\n        index += 2\n        \n        families[family_id].append(i + 1)\n        genders[i + 1] = gender\n    \n    results = []\n    for i in range(1, m + 1):\n        family_id = families[i][0]\n        gender = genders[i]\n        \n        if gender == 'M':\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc371_a",
    "code_list": [
      "def main():\n    s_ab = input().strip()\n    s_ac = input().strip()\n    s_bc = input().strip()\n    \n    # Determine the order: A, B, C\n    if s_ab == '<':\n        a_b = True\n    else:\n        a_b = False\n        \n    if s_ac == '<':\n        a_c = True\n    else:\n        a_c = False\n        \n    if s_bc == '<':\n        b_c = True\n    else:\n        b_c = False\n        \n    # Check for consistent order\n    if (a_b and not a_c) or (not a_b and a_c):\n        print(\"A\")\n    elif (b_c and not a_b) or (not b_c and a_b):\n        print(\"B\")\n    else:\n        print(\"C\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc372_a",
    "code_list": [
      "s = input().strip()\nresult = s.replace('.', '')\nprint(result)"
    ]
  },
  {
    "question_id": "abc373_a",
    "code_list": [
      "def main():\n    count = 0\n    for i in range(1, 13):\n        valid = True\n        for j in range(i):\n            if len(input().strip()) != i:\n                valid = False\n                break\n        if valid:\n            count += 1\n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc373_b",
    "code_list": [
      "def main():\n    s = input().strip()\n    \n    # Create a dictionary mapping characters to their positions\n    char_to_pos = {}\n    for i, ch in enumerate(s):\n        char_to_pos[ch] = i + 1\n    \n    # Calculate total distance using prefix sums\n    n = len(s)\n    prefix_sum = [0] * (n + 1)\n    \n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + char_to_pos[s[i]]\n    \n    total_distance = float('inf')\n    for i in range(1, n + 1):\n        current_distance = prefix_sum[n] - prefix_sum[i]\n        if current_distance < total_distance:\n            total_distance = current_distance\n    \n    print(total_distance)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc374_b",
    "code_list": [
      "s = input().strip()\nt = input().strip()\n\nif s == t:\n    print(0)\nelse:\n    for i in range(min(len(s), len(t))):\n        if s[i] != t[i]:\n            print(i + 1)\n            break\n    else:\n        print(max(len(s), len(t)))"
    ]
  },
  {
    "question_id": "abc374_a",
    "code_list": [
      "def main():\n    s = input().strip()\n    if s.endswith(\"san\"):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc375_b",
    "code_list": [
      "import sys\nfrom math import sqrt\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    \n    points = []\n    index = 1\n    for i in range(n):\n        x = int(data[index]); y = int(data[index+1])\n        index += 2\n        points.append((x, y))\n    \n    # Precompute distances between consecutive points\n    dists = []\n    for i in range(n):\n        dx = points[i][0] - points[(i+1) % n][0]\n        dy = points[i][1] - points[(i+1) % n][1]\n        dists.append(sqrt(dx*dx + dy*dy))\n    \n    # Compute total distance using Euler's formula\n    total_dist = 0.0\n    for i in range(n):\n        total_dist += dists[i]\n    \n    print(total_dist)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc375_a",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    n = int(data[0])\n    s = data[1].strip()\n    \n    count = 0\n    for i in range(n - 2):\n        if s[i] == '#' and s[i+1] == '#' and s[i+2] == '.':\n            count += 1\n            \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc376_a",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    c = int(data[1])\n    times = list(map(int, data[2:2+n]))\n    \n    count = 0\n    for t in times:\n        if t >= c:\n            count += 1\n            \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc377_b",
    "code_list": [
      "def main():\n    grid = []\n    for _ in range(8):\n        grid.append(input().strip())\n    \n    count = 0\n    \n    for i in range(8):\n        for j in range(8):\n            if grid[i][j] == '.':\n                valid = True\n                \n                # Check vertical line\n                for k in range(i + 1, 8):\n                    if grid[k][j] != '.':\n                        valid = False\n                        break\n                        \n                # Check horizontal line\n                for k in range(j + 1, 8):\n                    if grid[i][k] != '.':\n                        valid = False\n                        break\n                        \n                if valid:\n                    count += 1\n                    \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc377_a",
    "code_list": [
      "def main():\n    s = input().strip()\n    \n    # Count occurrences of each character\n    count_A = s.count('A')\n    count_B = s.count('B')\n    count_C = s.count('C')\n    \n    # Check if we have exactly one of each character\n    if count_A == 1 and count_B == 1 and count_C == 1:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc378_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    q_r_pairs = []\n    index = 1\n    for i in range(n):\n        q = int(data[index]); r = int(data[index+1])\n        index += 2\n        q_r_pairs.append((q, r))\n    \n    q_queries = []\n    index = index + n\n    for _ in range(q):\n        t = int(data[index]); d = int(data[index+1])\n        index += 2\n        q_queries.append((t, d))\n    \n    results = []\n    for t, d in q_queries:\n        # Find the smallest k such that (d - k * q) % r == 0\n        # This is equivalent to finding the smallest k such that d % r == k * q % r\n        # Since r < q, we can simplify this to finding the smallest k such that d % r == 0\n        # We need to find the smallest k such that d >= k * q\n        # If d < q, then k = 0 and d itself is the result\n        # Otherwise, k = d // q and the result is d - k * q\n        \n        if d < q:\n            results.append(d)\n        else:\n            k = d // q\n            results.append(d - k * q)\n    \n    print(\"\\n\".join(map(str, results)))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc378_a",
    "code_list": [
      "def main():\n    colors = list(map(int, input().split()))\n    \n    count_1 = colors.count(1)\n    count_2 = colors.count(2)\n    count_3 = colors.count(3)\n    count_4 = colors.count(4)\n    \n    max_operations = min(count_1, count_2) + min(count_3, count_4)\n    print(max_operations)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc379_b",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    n, k = map(int, data[0].split())\n    s = data[1].strip()\n    \n    count = 0\n    max_count = 0\n    \n    for char in s:\n        if char == 'O':\n            count += 1\n        else:\n            max_count = max(max_count, count)\n            count = 0\n            \n    # Check the last segment\n    max_count = max(max_count, count)\n    \n    result = max(0, max_count - k + 1)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc379_a",
    "code_list": [
      "def main():\n    n = int(input().strip())\n    \n    # Extract digits\n    hundreds = n // 100\n    tens = (n // 10) % 10\n    units = n % 10\n    \n    # Form new numbers\n    num1 = tens * 100 + units * 10 + hundreds\n    num2 = units * 100 + hundreds * 10 + tens\n    \n    print(f\"{num1} {num2}\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc380_a",
    "code_list": [
      "def main():\n    n = int(input().strip())\n    \n    # Convert to string for easy digit extraction\n    str_n = str(n)\n    \n    # Count occurrences of each digit\n    count_1 = str_n.count('1')\n    count_2 = str_n.count('2')\n    count_3 = str_n.count('3')\n    \n    # Check conditions\n    if count_1 == 1 and count_2 == 2 and count_3 == 3:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc380_b",
    "code_list": [
      "def main():\n    s = input().strip()\n    \n    # Find the position where the last '|' appears\n    last_pipe_index = s.rfind('|')\n    \n    if last_pipe_index == -1:\n        print(1)\n        return\n        \n    # Count the number of '-' segments\n    count = 0\n    for char in s[last_pipe_index + 1:]:\n        if char == '-':\n            count += 1\n            \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc381_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    n = int(data[0])\n    s = data[1].strip()\n    \n    if n % 2 == 0 or n < 3:\n        print(\"No\")\n        return\n        \n    count_1 = 0\n    count_2 = 0\n    \n    for char in s:\n        if char == '1':\n            count_1 += 1\n        elif char == '2':\n            count_2 += 1\n            \n    if count_1 != (n + 1) // 2 or count_2 != n // 2:\n        print(\"No\")\n        return\n        \n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc381_b",
    "code_list": [
      "def main():\n    s = input().strip()\n    \n    # Check if length is even\n    if len(s) % 2 != 0:\n        print(\"No\")\n        return\n        \n    n = len(s)\n    half_n = n // 2\n    \n    # Count frequency of each character\n    freq = {}\n    for char in s:\n        freq[char] = freq.get(char, 0) + 1\n        \n    # Check if all characters appear exactly twice\n    for count in freq.values():\n        if count != 2:\n            print(\"No\")\n            return\n            \n    # Check if each character appears at positions 2i-1 and 2i\n    valid = True\n    for i in range(1, half_n + 1):\n        char1 = s[2*i - 2]\n        char2 = s[2*i - 1]\n        \n        if char1 != char2:\n            valid = False\n            break\n            \n    if valid:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc382_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    n, d = map(int, data[0].split())\n    s = data[1].strip()\n    \n    # Count initial empty boxes\n    empty_count = s.count('.')\n    \n    # Process each day\n    for _ in range(d):\n        # Find all positions with '@'\n        positions_with_at = []\n        for i in range(n):\n            if s[i] == '@':\n                positions_with_at.append(i)\n        \n        # Remove all positions with '@' from the list\n        new_positions_with_at = []\n        for pos in positions_with_at:\n            if pos < len(s) - 1 and s[pos + 1] != '.':\n                new_positions_with_at.append(pos)\n        \n        # Update the count of empty boxes\n        empty_count -= len(new_positions_with_at)\n    \n    print(empty_count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc382_b",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    n, d = map(int, data[0].split())\n    s = data[1].strip()\n    \n    result = []\n    for i in range(n):\n        if s[i] == '@':\n            result.append('@')\n        else:\n            # Find last occurrence of @ to the right of current position\n            j = min(i + d, n)\n            while j > i and s[j - 1] != '@':\n                j -= 1\n            if j <= i:\n                result.append('.')\n            else:\n                result.append('@')\n    \n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc383_a",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    times = []\n    volumes = []\n    \n    index = 1\n    for i in range(n):\n        t = int(data[index]); index += 1\n        v = int(data[index]); index += 1\n        times.append(t)\n        volumes.append(v)\n    \n    total_water = 0\n    for i in range(n):\n        total_water += volumes[i]\n    \n    print(total_water)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc384_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    r = int(data[1])\n    \n    divs = []\n    for i in range(n):\n        d = int(data[2 + 2*i])\n        a = int(data[3 + 2*i])\n        divs.append((d, a))\n    \n    current_rating = r\n    for d, a in divs:\n        if d == 1:\n            current_rating += a\n    \n    print(current_rating)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc384_a",
    "code_list": [
      "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    if not data:\n        return\n    \n    n, c1, c2 = data[0].split()\n    n = int(n)\n    s = data[1]\n    \n    result = []\n    for char in s:\n        if char != c1:\n            result.append(c2)\n        else:\n            result.append(char)\n    \n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc385_a",
    "code_list": [
      "def main():\n    a, b, c = map(int, input().split())\n    \n    total_sum = a + b + c\n    \n    if total_sum % 2 != 0:\n        print(\"No\")\n        return\n        \n    target_sum = total_sum // 2\n    \n    # Check if we can form target_sum using a subset of {a, b, c}\n    # This is equivalent to checking if a, b, c can be partitioned into two sets\n    # such that both sets have equal sum\n    \n    # We'll use dynamic programming to solve this\n    n = max(a, b, c)\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    \n    for num in [a, b, c]:\n        if num > target_sum:\n            continue\n            \n        new_dp = [False] * (target_sum + 1)\n        for i in range(target_sum + 1):\n            if dp[i]:\n                new_dp[i] = True\n                if i + num <= target_sum:\n                    new_dp[i + num] = True\n                    \n        dp = new_dp\n        \n    result = \"Yes\" if dp[target_sum] else \"No\"\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc385_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    lines = data.split('\\n')\n    \n    H, W, X, Y = map(int, lines[0].split())\n    grid = []\n    for i in range(1, H + 1):\n        grid.append(lines[i].strip())\n    \n    T = lines[H + 1]\n    \n    current_x, current_y = X - 1, Y - 1\n    \n    visited = set()\n    visited.add((current_x, current_y))\n    \n    houses_passed = set()\n    \n    for char in T:\n        new_x, new_y = current_x, current_y\n        \n        if char == 'U':\n            new_y -= 1\n        elif char == 'D':\n            new_y += 1\n        elif char == 'L':\n            new_x -= 1\n        elif char == 'R':\n            new_x += 1\n            \n        if 0 <= new_x < H and 0 <= new_y < W:\n            if grid[new_x][new_y] == '.':\n                current_x, current_y = new_x, new_y\n                visited.add((current_x, current_y))\n                \n            elif grid[new_x][new_y] == '@':\n                houses_passed.add((current_x, current_y))\n                current_x, current_y = new_x, new_y\n                visited.add((current_x, current_y))\n                \n    print(f\"{current_x + 1} {current_y + 1} {len(houses_passed)}\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc386_a",
    "code_list": [
      "def main():\n    A, B, C, D = map(int, input().split())\n    \n    # Count occurrences of each number\n    count_A = A.count(A)\n    count_B = B.count(B)\n    count_C = C.count(C)\n    count_D = D.count(D)\n    \n    # Check for at least two numbers with exactly 3 occurrences\n    if (count_A == 3 or count_B == 3 or count_C == 3 or count_D == 3):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc386_b",
    "code_list": [
      "def main():\n    s = input().strip()\n    \n    # Count occurrences of each digit\n    count = {}\n    for char in s:\n        if char.isdigit():\n            count[char] = count.get(char, 0) + 1\n    \n    # Calculate minimum presses using greedy approach\n    min_presses = 0\n    for digit, freq in count.items():\n        min_presses += freq // 3\n        if freq % 3 > 0:\n            min_presses += 1\n            \n    print(min_presses)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  }
]